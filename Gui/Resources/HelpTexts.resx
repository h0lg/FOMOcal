<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ScrapeJobClosest" xml:space="preserve">
    <value>An optional selector to a common ancestor of the event container and the event detail - for when the event detail has to be selected from outside of the event container, like a group that only displays the date once for multiple events on the same day.</value>
  </data>
  <data name="EventContainerSelector" xml:space="preserve">
    <value>The selector to the event containers - of which there are probably multiple on the page, each containing as many of one event's details as possible - but only of a single event.

^^Some event pages for example display multiple events on the same day in a group. If you see it, use skip/take to try it out on such a group and choose a container that contains only one of their details - otherwise only the first event on any given day will be retrieved.
^^You'll be able to select the date or other excluded event details from outside your selected container later.</value>
  </data>
  <data name="ScrapeJobIgnoreNestedText" xml:space="preserve">
    <value>Whether to ignore the text of nested elements and only extract direct text nodes from the HTML. Does not apply if an attribute is set.</value>
  </data>
  <data name="ScrapeConfigInfo" xml:space="preserve">
    <value>Every web page is made up of 🖽 [boxes inside boxes](https://en.wikipedia.org/wiki/Document_Object_Model#DOM_tree_structure) - kind of like Russian nesting dolls, but often with more than one contained child.
Each box holds different parts of the page with different info. In the following, you can choose which boxes to pick what kind of info from.</value>
  </data>
  <data name="LazyLoaded" xml:space="preserve">
    <value>You may want to try this option if your event selector doesn't match anything without it even though it should*.
It will load the page and wait for an element matching your selector to become available, return when it does and time out if it doesn't.

^^This works around pages that lazy-load events. Some web servers only return an empty template of a page on the first request to improve the response time, then fetch more data asynchronously and render it into the placeholders using a script running in your browser.
^^
^^* To [test selectors](https://github.com/h0lg/FOMOcal?tab=readme-ov-file#debugging-selectors), load the page in your browser and start up a [developer console](https://developer.mozilla.org/en-US/docs/Learn_web_development/Howto/Tools_and_setup/What_are_browser_developer_tools#the_javascript_console). In there, use [$$('.css-selector')](https://developer.chrome.com/docs/devtools/console/utilities#querySelectorAll-function) or [$x('//xpath/selector')](https://developer.chrome.com/docs/devtools/console/utilities#xpath-function) depending on your chosen selector syntax.</value>
  </data>
  <data name="ScrapeJobAttribute" xml:space="preserve">
    <value>The name of the attribute of the selected element to extract the text from.</value>
  </data>
  <data name="ScrapeJobReplace" xml:space="preserve">
    <value>Multiple optional replacements to apply, in the form "Pattern }} Replacement || Pattern2 }}".
Use "||" to separate multiple replacements and "}}" to separate the pattern from the replacement, which may be empty.
You may want to do this e.g. to convert a date string into a valid format. Patterns are [Regular Expressions](https://en.wikipedia.org/wiki/Regular_expression) in .NET flavor, but plain text often works.

^^[regex101](https://regex101.com/) is great to debug your patterns, learn and find existing patterns. If you can't be bothered or are struggling - ask a chat bot for help, they're pretty good at this.
^^
^^This and following steps are applied after normalizing consecutive whitespace in the selected text to a single space.</value>
  </data>
  <data name="ScrapeJobMatch" xml:space="preserve">
    <value>A pattern ([Regular Expressions](https://en.wikipedia.org/wiki/Regular_expression) in .NET flavor) that matches the part of text to extract. You may want to do this to extract text that is not cleanly selectable.

^^[regex101](https://regex101.com/) is great to debug your RegEx, learn and find existing patterns. If you can't be bothered or are struggling - ask a chat bot for help, they're pretty good at this.</value>
  </data>
  <data name="DateScrapeJobFormat" xml:space="preserve">
    <value>The .NET [custom](https://learn.microsoft.com/en-us/dotnet/standard/base-types/custom-date-and-time-format-strings) or [standard](https://learn.microsoft.com/en-us/dotnet/standard/base-types/standard-date-and-time-format-strings) date format/s used to parse the date.

If you want to try parsing the date in different formats, separate them with two || pipes. That may be required for venues that e.g. omit the year for event dates in the current year, but not in the next.

^^ddd | dddd – Weekday (short | full name)
^^d | dd – Day of month (no | with leading zero)
^^M | MM – Month number (no | with leading zero)
^^MMM | MMMM – Month name (short | full)
^^yy | yyyy – Year (2 | 4 digits)
^^separators like . / , where they occur

^^e.g. "Mon, 09 Jun 2025" would be "ddd, dd MMM yyyy"</value>
  </data>
  <data name="DateScrapeJobCulture" xml:space="preserve">
    <value>The [language/country code](https://en.wikipedia.org/wiki/Language_code) used to parse the date in ISO 639 (en) or ISO 3166 format (en-US).</value>
  </data>
  <data name="SelectorSyntaxFormat" xml:space="preserve">
    <value>What's the difference? In most cases you'll want to use [CSS](https://www.w3schools.com/cssref/css_selectors.php) for its shorter and simpler selector syntax.

# XPath
For advanced scenarios you may want to try [XPath](https://www.w3schools.com/xml/xpath_syntax.asp), which has more features like [traversing along different axes](https://developer.mozilla.org/en-US/docs/Web/XML/XPath/Reference/Axes) in the document or [powerful functions](https://developer.mozilla.org/en-US/docs/Web/XML/XPath/Reference/Functions).
^^Make sure to stick to XPath 1.0 features and prefix your selector with '{0}'. Using the ➕ append button will do that for you.
^^E.g. to select elements with class 'event', you'd write:
^^{0}//div[contains(@class, 'event')]</value>
  </data>
  <data name="EnablePicking" xml:space="preserve">
    <value>Toggle picking mode.
You may want to disable this to interact with the page as you would in a normal browser, e.g. to close popups and overlays
- or play with those eye-opening 🍪 cookie reminders sponsored by the EU if you're lucky enough to be browsing from there.</value>
  </data>
  <data name="AppendSelectedQuery" xml:space="preserve">
    <value>Appends to the existing query if it matches the syntax, otherwise replaces it.</value>
  </data>
  <data name="PickedSelectorDisplay" xml:space="preserve">
    <value>You need some part of the selector in the last line - it selects the element you picked. Select the part you want and use ➕ append.</value>
  </data>
  <data name="ScrapeJobSelector" xml:space="preserve">
    <value>A selector to the element containing the text of the event detail.</value>
  </data>
  <data name="NextEventPageSelector" xml:space="preserve">
    <value>The selector of the element to click or link to navigate to load more or different events.</value>
  </data>
  <data name="PagingStrategyAllOnOne" xml:space="preserve">
    <value>All events are loaded into the first page - no paging required.</value>
  </data>
  <data name="PagingStrategyClickElementToLoadMore" xml:space="preserve">
    <value>More events are loaded into the same page after clicking an element.</value>
  </data>
  <data name="PagingStrategyNavigateLinkToLoadDifferent" xml:space="preserve">
    <value>Different events are loaded on the next page after navigating a hyperlink.</value>
  </data>
  <data name="PagingStrategyScrollDownToLoadMore" xml:space="preserve">
    <value>More events are loaded into the same page by scrolling it down.</value>
  </data>
  <data name="PagingStrategyClickElementToLoadDifferent" xml:space="preserve">
    <value>Different events are loaded into the same page after clicking an element.</value>
  </data>
  <data name="IncludePickedSelectorPath" xml:space="preserve">
    <value>The ancestor path or parts of it can help increase the specificity of your selector if the picked element itself doesn't offer enough, e.g. doesn't have classes.</value>
  </data>
  <data name="TagName" xml:space="preserve">
    <value>The name of the HTML tag of the element you picked. It doesn't have much specificity on its own, because a page usually contains many elements with the same tag name - but it can add to that of your selector and is better than choosing just any element.</value>
  </data>
  <data name="ElementId" xml:space="preserve">
    <value>The ID of the picked node. Should be unique in the document according to HTML spec - but may not be.

^^Potentially a selector detail with very high specificity - too high if they are unique and you want to select a re-occurring element.</value>
  </data>
  <data name="ClassesWith_Style" xml:space="preserve">
    <value>Classes that have{0} visual styles attached.
This may be a hint they are or are not good selectors, depending on the page.

^^Classes are used for reoccurring elements and can be combined to increase specificity.
^^
^^If the semantics of a class name match what you're selecting for, it's probably a good fit.</value>
  </data>
  <data name="OtherAttributes" xml:space="preserve">
    <value>Existence of attributes other than id or class. Some depend on the element tag/name - so not/having different attributes will have varying specificity.</value>
  </data>
  <data name="OtherAttributeValues" xml:space="preserve">
    <value>The values of attributes other than id or class. Depending on the attribute, this may be a useful selector or too specific.</value>
  </data>
  <data name="ElementPosition" xml:space="preserve">
    <value>The (1-based) position of the picked element relative to its siblings (of the same tag/element name) in their parent. This is quite a fragile selector detail - only use this if you have no other alternatives.</value>
  </data>
  <data name="ToggleSelectorDetail" xml:space="preserve">
    <value>Toggle selector details for your picked element. More detail means more specificity - but beware that every moving part also increases the fragility of your selector. You'll want to find the sweet spot.</value>
  </data>
  <data name="Encoding" xml:space="preserve">
    <value>Re-interpret the extracted text using a specific character set. Try setting this to e.g. "UTF-8" if you notice incorrectly encoded characters in it. This is useful for the rare web page containing text with a different character set from what it (or the webserver that serves it) claims to contain.

You can specify one or two values, separated by a | pipe.

The first will be used for interpreting text directly from the page's HTML, the second to encode HTML passed across the JS bridge by the automated browser. The latter is used here to let you pick selectors and load the event preview - and during scraping, if you choose "wait for JS rendering" or a loading strategy other than "all on the first page" below.

If you specify only one encoding without a pipe, it's used for both flavors.
To default either value to the encoding the page or server claims, omit it; e.g. "|UTF-8" will only re-interpret the encoding of the HTML received from the automated browser.</value>
  </data>
  <data name="Comment" xml:space="preserve">
    <value>A note explaining something you're doing - e.g. in the selector or the RegEx - that's complicated or not obvious.</value>
  </data>
  <data name="EventContainerFilterFormat" xml:space="preserve">
    <value>Filters the selected event containers. Supply a simple case-insensitive substring the container text must contain.
You may also use XPath for more control - if you do, stick to XPath 1.0 features and pre-fix your filter with '{0}'.

^^You could do this in the selector - but you'd have to write both selection and filtering in the more complicated XPath syntax.
^^Also, pre-filtering events in the selector will cause initial loading to run into a timeout when waiting for lazy-loaded events and the page contains no matches.
^^
^^E.g. to filter for containers that have a 'category' class div with the cleaned text 'concert' using XPath, you'd write:
^^{0}.//div[@class='category' and normalize-space(.)='concert']</value>
  </data>
  <data name="TestPagingStrategy" xml:space="preserve">
    <value>🧪 Test this strategy to load more events. You can watch the process in the 🖽 Visual Selector, e.g. the one for the event selector.
If you test a strategy that involves clicking, make sure to disable the option "Tap a page element to pick it."</value>
  </data>
  <data name="SaveScrapLogs" xml:space="preserve">
    <value>Log the scrape process, across event paging if configured.
Automatically included in the error log if an error occurs.

This option saves the scrape logs even without error to debug your scrape config - e.g. if it's unreliable or doesn't yield the expected number of results.</value>
  </data>
</root>